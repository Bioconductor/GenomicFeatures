%\VignetteIndexEntry{Making and Utilizing TranscriptDb Objects}
%\VignetteKeywords{annotation}
%\VignettePackage{GenomicFeatures}
\documentclass[11pt]{article}

\newcommand{\Rfunction}[1]{{\texttt{#1}}}
\newcommand{\Robject}[1]{{\texttt{#1}}}
\newcommand{\Rpackage}[1]{{\textit{#1}}}
\newcommand{\Rmethod}[1]{{\texttt{#1}}}
\newcommand{\Rfunarg}[1]{{\texttt{#1}}}
\newcommand{\Rclass}[1]{{\textit{#1}}}
\newcommand{\Rcode}[1]{{\texttt{#1}}}


\title{Making and Utilizing TranscriptDb Objects}
\author{Biocore Team}

\SweaveOpts{keep.source=TRUE}

\begin{document}

\maketitle


\section{Introduction}

The \Rpackage{GenomicFeatures} package retrieves and manages
transcript-related features from UCSC Genome Bioinformatics and
BioMart data resources. The package is useful for ChIP-chip, ChIP-seq,
and RNA-seq analyses.

<<loadGenomicFeatures>>=
library(GenomicFeatures)
@


\section{Transcript Metadata}

\subsection{\Rclass{TranscriptDb} Objects}

The \Rpackage{GenomicFeatures} package uses \Rclass{TranscriptDb}
objects to store transcript metadata. This class is designed to map
the 5' untranslated regions (UTRs), protein coding sequence (CDSs),
and 3' UTRs for a set mRNA transcripts to their associated genome,
where the combined 5' UTR, CDS, and 3' UTR region for an mRNA
transcript either originated from a single exon or from multiple
exons that were post-transcriptionally spliced.

As the suffix of the class name suggests, \Rclass{TranscriptDb}
objects are backed by a SQLite database. This database manages genomic
locations and the relationships between pre-processed mRNA
transcripts, exons, protein coding sequences, and their related gene
IDs.

\subsection{Creating New \Rclass{TranscriptDb} Objects}

There are three methods for creating new \Rclass{TranscriptDb} objects
in the \Rpackage{GenomicFeatures} package:
\begin{enumerate}
\item Download from UCSC Genome Bioinformatics;
\item Download from BioMart;
\item Use a \Rclass{data.frame} containing transcript metadata.
\end{enumerate}

The function \Rfunction{makeTranscriptDbFromUCSC} downloads UCSC
Genome Bioinformatics transcript tables (e.g. \Rcode{"knownGene"},
\Rcode{"refGene"}, \Rcode{"ensGene"}) for a genome build (e.g.
\Rcode{"mm9"}, \Rcode{"hg19"}).  Use the
\Rfunction{supportedUCSCtables} utility function to get the list of
supported tables.
%% 
<<supportedUCSCtables>>=
supportedUCSCtables()
@ 
<<makeTranscriptDbFromUCSC, eval=FALSE>>=
mm9KG <- makeTranscriptDbFromUCSC(genome = "mm9", tablename = "knownGene")
@

Retrieve data from BioMart by specifying the `mart' and data set (not
all BioMart data sets are currently supported):
%% 
<<makeTranscriptDbFromBiomart, eval=FALSE>>=
mmusculusEnsembl <- 
  makeTranscriptDbFromBiomart(biomart = "ensembl",
                              dataset = "mmusculus_gene_ensembl")
@

The function \Rfunction{makeTranscriptDb} creates \Rclass{TransctriptDb}
objects from \Rclass{data.frame} objects.


\subsection{Saving and Loading a TranscriptDb Object}

\Rclass{TranscriptDb} objects can be saved as sqlite files for future
access (e.g., to easily reproduce results with identical genomic
feature data at a later date, or for access from programs other than
R).  
%% 
<<saveFeatures 1, eval=FALSE>>=
saveFeatures(mm9KG, file="fileName.sqlite")
@
%% 
Load a saved \Rclass{TranscriptDb} object with
\Rfunction{loadFeatures}:
## 
<<loadFeatures-1, eval=FALSE>>=
mm9KG <- loadFeatures("fileName.sqlite")
@
%% 
For instance, a sample of UCSC known genes is included in
\Rpackage{GenomicFeatures}.
<<load_UCSC_KG>>=
exampleFile <-
    system.file("extdata", "UCSC_knownGene_sample.sqlite",
                package="GenomicFeatures")
txdb <- loadFeatures(exampleFile)
txdb
@ 
%% 
In addition to transcript data, the object contains information about
how it was created (e.g., the number of transcripts, exons, and coding
sequence rows) and about software versions and creation dates.

\section{Retrieving Transcript, Exon, and Coding Sequence Ranges}

The \Rfunction{transcriptsByRanges}, \Rfunction{exonsByRanges} and
\Rfunction{cdsByRanges} functions return a \Rclass{GRangesList} object
containing data about transcripts, exons, or coding sequences that
overlap genomic coordinates specified by a \Rclass{GRanges}
object.
%% 
<<transcriptsByRanges>>=
library(org.Mm.eg.db)
set.seed(0L)
idx <- sample(length(org.Mm.egCHRLOC), 50)
tbl <- unique(merge(toTable(org.Mm.egCHRLOC[idx]), 
                    toTable(org.Mm.egCHRLOCEND[idx])))
gr <- with(tbl, {
    lvls <- paste("chr", c(1:19, "X", "Y", "MT", "Un"), sep="")
    GRanges(seqnames=factor(paste("chr", Chromosome, sep=""), 
                            levels=lvls),
            ranges=IRanges(abs(start_location), abs(end_location)), 
            strand=ifelse(start_location >= 0, "+", "-"),
            egid=gene_id)
})
transcriptsByRanges(txdb, gr)
@

The \Rfunction{bindTranscripts}, \Rfunction{bindExons} and
\Rfunction{bindCDS} add transcript, exon, or coding sequence data to
rows of a \code{GRanges} object.
%% 
<<bindTranscripts>>=
bindTranscripts(txdb, gr)
@

\section{Examples}

\subsection{Features overlapped by experimental data}

So lets suppose that you have run an experiment. After mapping all
your reads to a genome and collapsing them into a set of ranges, you
want to find out what genomic Features a particular range overlaps
with.  Here is how you might proceed:

<<mapTranscripts 1, eval=FALSE>>=
##gr will represent the GRanges object that you have (your data)
gr <- GRanges(seqnames = "chr1",
              ranges = IRanges(start=6700,end=7700),
              strand = "-")

bindTranscripts(txdb, gr)
bindExons(txdb, gr)
@


\subsection{Retrieving data from an RNA-seq experiment}

Lets take the case where you have some RNA-seq data and you want to
convert your ranges into counts representing how many hits per gene.


<<RNASEQ1, eval=FALSE>>=
## gr will represent the GRanges object that you have (your data)
gr <- GRanges(seqnames = "chr5",
              ranges = IRanges(start = c(244620,244670,245804,247502),
                               end = c(244652,244702,245836,247534)),
              strand = "+")

## recover the annotations
annotGR <- transcriptsByRanges(txdb, gr, columns=c("tx_id","tx_name",
                                           "gene_id", "exon_id"))

## Get the overlap between the annotations and your data
OL <- findOverlaps(gr, annotGR, multiple=TRUE)

## just get the data that you want
tdata <- annotGR[subjectHits(OL),]

## And then get the count per transcript:
table(tdata$tx_id)

## And the count per gene:
table(unlist(tdata$gene_id))
@

% Now lets assume that you want to search ONLY the exons for your
% transcripts (and not just the entire transcript as is done above). How
% could you do that?

%<<RNASEQ2, eval=FALSE>>=
%## recover the exon annotations
%annotGREx <- exonsByRanges(txdb, gr)

%## Get the overlap between the annotations and your data
%OL <- findOverlaps(gr, annotGREx, multiple=TRUE)

%## just get the data that you want
%edata <- annotGREx[subjectHits(OL),]

%## And then get the count per exon:
%table(edata$exon_id)

%## For each exon ID, you can retrieve potential Gene IDs from our previous
%## call to transcriptsByRanges() BUT, be warned that this can be a many to
%## many relationship

%@



%%TODO: work with Herve to improve the toy annotations so that we can have more interesting results in the example.

\subsection{Finding data for a Chip-seq experiment}

What would we do differently if we had chip-seq data?  Lets imagine
the we have a collection of reads in a \Rclass{GRanges} object
as below.  We want to learn if these reads are 1) near to any
transcript annotations and 2) if the list of things that they are near
to are interesting or not.

<<CHIPSEQ1, eval=FALSE>>=
## gr will represent the GRanges object that you have (your data)
gr <- GRanges(seqnames = "chr5",
              ranges = IRanges(start = c(244501,244553,244580,244523),
                               end = c(244533,244585,244612,244555)), 
              strand = "+")

## If we try to find annotations for this we discover that there are none
## overlapping this feature...
transcriptsByRanges(txdb, gr, columns=c("tx_id","tx_name","gene_id"))


## So we will extend the gr object by a constant amount of 200 base pairs so
## that each read has an opportunity to overlap with something interesting.
grExt <- gr
ranges(grExt) <- ranges(grExt)+100

## Then collapse the annotations
grExt <- reduce(grExt)

## And recover the annotations that match
annotGR <- transcriptsByRanges(txdb, grExt, 
                               columns=c("tx_id","tx_name","gene_id"))

## Then find the number of unique matching gene IDs 
unique(unlist(values(annotGR)$gene_id))
@


Once you have a gene list, you should be able to do a GSEA analysis using the
Category or GOstats packages.



% To answer the question of whether or not the reduced and extended peaks overlap with interesting genes, we can just call unique on the gene_id column and then apass that along to a 

%%next just need the example data above to include starts and stops to land near a few related things, THEN I just need to show how you can get the unique(gene)ids) out and pass those along to a GSEA




%% TODO: 
%% 1) Add section for an RNA-seq application 
%%   a. spoof some data 
%%   b. findOverlaps() = counts between fake-data and data from 
%%      transcriptsByRanges() OR you can just use bindTranscripts().
%%   c. count how many of each gene are hit for each mapped (unique) range 
%% 2) Add an example for a chip-seq application.
%%   a. spoof data and then EXTEND it so that it can "overlap" in next step 
%%   b. call transcriptsByRanges to get relevant data or bindTranscripts()
%%   c. get the list of gene IDs out
%%   d. do GSEA on the gene list

%% To this end the better part of our test database to test against is 
%% probably chromosome 5: 
%% specifically:
%% 153478      chr5        +           193373.0    243087.0  
%% 389257      chr5        +           244626.0    248468.0  
%% 133957      chr5        -           257875.0    271297.0  



\subsection{Working with Grouped Features}

Sometimes you will want to consider ranged annotation data that is
grouped in a specific way, e.g. the transcripts associated with a
gene and the exon composition of a transcript. These relationships
are maintained with \Rclass{TranscriptDb} objects and can be
accessed through the \Rfunction{transcriptsBy}, \Rfunction{exonsBy},
and \Rfunction{cdsBy} functions.

So for example, to extract all the transcripts grouped by their exons
you can call:

<<transcriptsBy>>=
txdb <- loadFeatures(system.file("extdata", "UCSC_knownGene_sample.sqlite",
                                 package="GenomicFeatures"))
GRList <- transcriptsBy(txdb, "gene")
GRList
@


Similarly, to extract all the exons for each transcript you can call:

<<exonsBy>>=
txdb <- loadFeatures(system.file("extdata", "UCSC_knownGene_sample.sqlite",
                                 package="GenomicFeatures"))
GRList <- exonsBy(txdb, "tx")
GRList
@

These functions return \Rclass{GRangesList} objects that contain
locations and identifiers. These objects can be used in downstream
analyses such as using \Rfunction{findOverlaps} contextualize the
alignments from high-throughput sequencing.


\section{Session Information}

The version number of R and packages loaded for generating the vignette were:

<<SessionInfo, echo=FALSE>>=
sessionInfo()
@

\end{document}
