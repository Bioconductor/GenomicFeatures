%\VignetteIndexEntry{Making and Utilizing TranscriptDb Objects}
%\VignetteKeywords{annotation}
%\VignettePackage{GenomicFeatures}
\documentclass[11pt]{article}

\newcommand{\Rfunction}[1]{{\texttt{#1}}}
\newcommand{\Robject}[1]{{\texttt{#1}}}
\newcommand{\Rpackage}[1]{{\textit{#1}}}
\newcommand{\Rclass}[1]{{\textit{#1}}}
\newcommand{\Rcode}[1]{{\texttt{#1}}}


\title{Making and Utilizing TranscriptDb Objects}
\author{Biocore Team}

\SweaveOpts{keep.source=TRUE}

\begin{document}

\maketitle


\section{Introduction}

The \Rpackage{GenomicFeatures} package is designed to obtain genomic
features metadata from UCSC Genome Bioinformatics and BioMart for
ChIP-chip, ChIP-seq, and RNA-seq analyses. It is currently focused on
transcript-related features, but its scope will grow in future releases.

<<loadGenomicFeatures>>=
library(BSgenome)
library(GenomicFeatures)
@


\section{Transcript Metadata}

\subsection{\Rclass{TranscriptDb} Objects}

The \Rpackage{GenomicFeatures} package uses \Rclass{TranscriptDb}
objects to store transcript metadata. This class is designed to map
the 5' untranslated regions (UTRs), protein coding sequence (CDSs),
and 3' UTRs for a set mRNA transcripts to their associated genome,
where the combined 5' UTR, CDS, and 3' UTR region for an mRNA
transcript either originated from a single exon or from multiple
exons that were spliced together post-transcription.

As the suffix of the class name suggests, \Rclass{TranscriptDb}
objects are backed by a SQLite database. This database manages:

\begin{enumerate}
\item genomic locations for pre-processed mRNA transcripts
\item genomic locations for exons 
\item genomic locations for protein coding sequences 
\item the relationships amongst mRNA transcripts, exons, protein
  coding sequences and associated gene IDs.
\end{enumerate}


\subsection{Creating New \Rclass{TranscriptDb} Objects}

The \Rpackage{GenomicFeatures} package contains three methods for
creating new \Rclass{TranscriptDb} objects:

\begin{enumerate}
\item Download from a UCSC Genome Bioinformatics
\item Download from BioMart
\item Use \Rclass{data.frame} objects containing transcript metadata
\end{enumerate}


\subsubsection{UCSC Genome Bioinformatics}

The function \Rfunction{makeTranscriptDbFromUCSC} downloads UCSC Genome
Bioinformatics transcript tables (e.g. \Rcode{"knownGene"},
\Rcode{"refGene"}, \Rcode{"ensGene"}) for a genome build (e.g.
\Rcode{"mm9"}, \Rcode{"hg19"}).
Use the \Rfunction{supportedUCSCtables} utility function to get the
list of supported tables.

<<makeTranscriptDbFromUCSC, eval=FALSE>>=
mm9KG <- makeTranscriptDbFromUCSC(genome = "mm9", tablename = "knownGene")
mm9KG
@


\subsubsection{BioMart}

<<makeTranscriptDbFromBiomart, eval=FALSE>>=
mmusculusEnsembl <- 
  makeTranscriptDbFromBiomart(biomart = "ensembl",
                              dataset = "mmusculus_gene_ensembl")
@


\subsubsection{\Rclass{data.frame} Inputs}

The function \Rfunction{makeTranscriptDb} creates \Rclass{TransctriptDb}
objects from \Rclass{data.frame} objects.


\subsection{Saving and Loading a TranscriptDb Object}

When you 1st make your \Rclass{TranscriptDb} object, it is running from a
temporary file.  In order to save it you need to use the
\Rfunction{saveFeatures} function.

<<saveFeatures 1, eval=FALSE>>=
saveFeatures(txAnn, file="fileName.sqlite")
@

To retrieve the \Rclass{TranscriptDb} object, you only need to use the
\Rfunction{loadFeatures} function.

<<loadFeatures 1, eval=FALSE>>=
loadFeatures("fileName.sqlite")
@

<<load_UCSC_KG>>=
txdb <- loadFeatures(system.file("extdata", "UCSC_knownGene_sample.sqlite",
                                 package="GenomicFeatures"))
@


\subsection{Getting Transcript Ranges}


\subsection{Getting Overlapped Transcript Ranges}

The \Rfunction{transcriptsByRanges} function returns a
\Rclass{GRangesList} object containing metadata for transcripts that
are overlapped by specified locations from a \Rclass{GRanges} object.

<<transcriptsByRanges>>=
gr <- GRanges(seqnames = rep("chr1",2),
              ranges = IRanges(start=c(500,10500),end=c(10000,30000)),
              strand = rep("-",2))
transcriptsByRanges(txdb, gr)
@


\subsection{Binding Transcript Data to a GRanges Object}


<<bindTranscripts>>=
gr <- GRanges(seqnames = rep("chr1",2),
              ranges = IRanges(start=c(500,10500),end=c(10000,30000)),
              strand = rep("-",2))
bindTranscripts(txdb, gr)
@



\subsection{Examples}

\subsubsection{Example: Retrieving data from an experiment}

So lets suppose that you have run an experiment. After mapping all
your reads to a genome and collapsing them into a set of ranges, you
want to find out what genomic Features a particular range overlaps
with.  Here is how you might proceed:

<<mapTranscripts 1, eval=FALSE>>=
##gr will represent the GRanges object that you have (your data)
gr <- GRanges(seqnames = "chr1",
              ranges = IRanges(start=6700,end=7700),
              strand = "-")

bindTranscripts(txdb, gr)

bindExons(txdb, gr)
@


\subsubsection{Example: Retrieving data from an RNA-seq experiment}

Lets take the case where you have some RNA-seq data and you want to
convert your ranges into counts representing how many hits per gene.


<<RNASEQ1, eval=FALSE>>=
## gr will represent the GRanges object that you have (your data)
gr <- GRanges(seqnames = "chr5",
              ranges = IRanges(start = c(244620,244670,245804,247502),
                               end = c(244652,244702,245836,247534)),
              strand = "+")

## recover the annotations
annotGR <- transcriptsByRanges(txdb, gr, columns=c("tx_id","tx_name",
                                           "gene_id", "exon_id"))

## Get the overlap between the annotations and your data
OL <- findOverlaps(gr, annotGR, multiple=TRUE)

## just get the data that you want
tdata <- annotGR[subjectHits(OL),]

## And then get the count per transcript:
table(tdata$tx_id)

## And the count per gene:
table(unlist(tdata$gene_id))
@

% Now lets assume that you want to search ONLY the exons for your
% transcripts (and not just the entire transcript as is done above). How
% could you do that?

%<<RNASEQ2, eval=FALSE>>=
%## recover the exon annotations
%annotGREx <- exonsByRanges(txdb, gr)

%## Get the overlap between the annotations and your data
%OL <- findOverlaps(gr, annotGREx, multiple=TRUE)

%## just get the data that you want
%edata <- annotGREx[subjectHits(OL),]

%## And then get the count per exon:
%table(edata$exon_id)

%## For each exon ID, you can retrieve potential Gene IDs from our previous
%## call to transcriptsByRanges() BUT, be warned that this can be a many to
%## many relationship

%@



%%TODO: work with Herve to improve the toy annotations so that we can have more interesting results in the example.

\subsubsection{Example: Finding data for a Chip-seq experiment}

What would we do differently if we had chip-seq data?  Lets imagine
the we have a collection of reads in a \Rclass{GRanges} object
as below.  We want to learn if these reads are 1) near to any
transcript annotations and 2) if the list of things that they are near
to are interesting or not.

<<CHIPSEQ1, eval=FALSE>>=
## gr will represent the GRanges object that you have (your data)
gr <- GRanges(seqnames = "chr5",
              ranges = IRanges(start = c(244501,244553,244580,244523),
                               end = c(244533,244585,244612,244555)), 
              strand = "+")

## If we try to find annotations for this we discover that there are none
## overlapping this feature...
transcriptsByRanges(txdb, gr, columns=c("tx_id","tx_name","gene_id"))


## So we will extend the gr object by a constant amount of 200 base pairs so
## that each read has an opportunity to overlap with something interesting.
grExt <- gr
ranges(grExt) <- ranges(grExt)+100

## Then collapse the annotations
grExt <- reduce(grExt)

## And recover the annotations that match
annotGR <- transcriptsByRanges(txdb, grExt, 
                               columns=c("tx_id","tx_name","gene_id"))

## Then find the number of unique matching gene IDs 
unique(unlist(values(annotGR)$gene_id))
@


Once you have a gene list, you should be able to do a GSEA analysis using the Category or GOstats packages.



% To answer the question of whether or not the reduced and extended peaks overlap with interesting genes, we can just call unique on the gene_id column and then apass that along to a 

%%next just need the example data above to include starts and stops to land near a few related things, THEN I just need to show how you can get the unique(gene)ids) out and pass those along to a GSEA




%% TODO: 
%% 1) Add section for an RNA-seq application 
%%   a. spoof some data 
%%   b. findOverlaps() = counts between fake-data and data from 
%%      transcriptsByRanges() OR you can just use bindTranscripts().
%%   c. count how many of each gene are hit for each mapped (unique) range 
%% 2) Add an example for a chip-seq application.
%%   a. spoof data and then EXTEND it so that it can "overlap" in next step 
%%   b. call transcriptsByRanges to get relevant data or bindTranscripts()
%%   c. get the list of gene IDs out
%%   d. do GSEA on the gene list

%% To this end the better part of our test database to test against is 
%% probably chromosome 5: 
%% specifically:
%% 153478      chr5        +           193373.0    243087.0  
%% 389257      chr5        +           244626.0    248468.0  
%% 133957      chr5        -           257875.0    271297.0  


\section{Session Information}

The version number of R and packages loaded for generating the vignette were:

<<SessionInfo, echo=FALSE>>=
sessionInfo()
@

\end{document}
