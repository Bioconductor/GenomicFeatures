%\VignetteIndexEntry{Making and Utilizing TranscriptDb Objects}
%\VignetteKeywords{annotation}
%\VignettePackage{GenomicFeatures}
\documentclass[11pt]{article}

\usepackage{url}

\newcommand{\Rfunction}[1]{{\texttt{#1}}}
\newcommand{\Robject}[1]{{\texttt{#1}}}
\newcommand{\Rpackage}[1]{{\textit{#1}}}
\newcommand{\Rmethod}[1]{{\texttt{#1}}}
\newcommand{\Rfunarg}[1]{{\texttt{#1}}}
\newcommand{\Rclass}[1]{{\textit{#1}}}
\newcommand{\Rcode}[1]{{\texttt{#1}}}
\newcommand{\software}[1]{\textsf{#1}}
\newcommand{\R}{\software{R}}


\title{Making and Utilizing TranscriptDb Objects}
\author{Marc Carlson \and
  Patrick Aboyoun \and
  Herv\'{e} Pag\`{e}s \and
  Seth Falcon \and
  Martin Morgan}

\SweaveOpts{keep.source=TRUE}

\begin{document}

\maketitle


\section{Introduction}

The \Rpackage{GenomicFeatures} package retrieves and manages
transcript-related features from the UCSC Genome
Bioinformatics\footnote{\url{http://genome.ucsc.edu/}} and
BioMart\footnote{\url{http://www.biomart.org/}} data resources. The
package is useful for ChIP-chip, ChIP-seq, and RNA-seq analyses.

<<loadGenomicFeatures>>=
library("GenomicFeatures")
@


\section{Transcript Metadata}

\subsection{\Rclass{TranscriptDb} Objects}

The \Rpackage{GenomicFeatures} package uses \Rclass{TranscriptDb}
objects to store transcript metadata. This class maps the 5' and 3'
untranslated regions (UTRs) and protein coding sequences (CDSs) for a
set of mRNA transcripts to their associated genome, where the combined
5' UTR, CDS, and 3' UTR region for an mRNA transcript either
originated from a single exon or from multiple exons that were
post-transcriptionally spliced.
%% FIXME

\Rclass{TranscriptDb} objects are backed by a SQLite database that
manages genomic locations and the relationships between pre-processed
mRNA transcripts, exons, protein coding sequences, and their related
gene identifiers.

\subsection{Creating New \Rclass{TranscriptDb} Objects}

The \Rpackage{GenomicFeatures} package provides function to create
\Rclass{TranscriptDb} objects based on data downloaded from UCSC
Genome Bioinformatics or BioMart. The following subsections
demonstrate the use of these functions.  There is also support for
creating \Rclass{TranscriptDb} objects from custom data sources using
\Rfunction{makeTranscriptDb}; see the help page for this function for
details.

\subsubsection{Using \Rfunction{makeTranscriptDbFromUCSC}}


The function \Rfunction{makeTranscriptDbFromUCSC} downloads UCSC
Genome Bioinformatics transcript tables (e.g. \Rcode{"knownGene"},
\Rcode{"refGene"}, \Rcode{"ensGene"}) for a genome build (e.g.
\Rcode{"mm9"}, \Rcode{"hg19"}).  Use the
\Rfunction{supportedUCSCtables} utility function to get the list of
supported tables.
%%
<<supportedUCSCtables>>=
supportedUCSCtables()[1:4, ]
@
<<makeTranscriptDbFromUCSC, eval=FALSE>>=
mm9KG <- makeTranscriptDbFromUCSC(genome = "mm9", tablename = "knownGene")
@

\subsubsection{Using \Rfunction{makeTranscriptDbFromBiomart}}

Retrieve data from BioMart by specifying the mart and the data set (not
all BioMart data sets are currently supported):
%%
<<makeTranscriptDbFromBiomart, eval=FALSE>>=
mmusculusEnsembl <-
  makeTranscriptDbFromBiomart(biomart = "ensembl",
                              dataset = "mmusculus_gene_ensembl")
@

%% FIXME: comment on expected size of data required for download, and
%% processing time.  This provides a natural lead-in to the save/load
%% section since creating the txdb objects requires time and
%% bandwidth.

\subsection{Saving and Loading a \Rclass{TranscriptDb} Object}

Once a \Rclass{TranscriptDb} object has been created, it can be saved
to avoid the time and bandwidth costs of recreating it and to make it
possible to reproduce results with identical genomic feature data at a
later date.  Since \Rclass{TranscriptDb} objects are backed by a
SQLite database, the save format is a SQLite database file (which
could be accessed from programs other than \R if desired).  Note that
it is not possible to serialize a \Rclass{TranscriptDb} object using
\R's \Rfunction{save} function.

%%
<<saveFeatures 1, eval=FALSE>>=
saveFeatures(mm9KG, file="fileName.sqlite")
@

A \Rclass{TranscriptDb} object can be initialized from a file using
\Rfunction{loadFeatures}.

<<loadFeatures-1, eval=FALSE>>=
mm9KG <- loadFeatures("fileName.sqlite")
@

\section{Retrieving Transcript, Exon, and Coding Sequence Ranges}

\subsection{Loading the sample genomic feature data}

A subset of a previously created \Rclass{TranscriptDb} object based on
UCSC known gene data is included to make it easier to demonstrate
functionality in the \Rpackage{GenomicFeatures} package.  Below, we
load the sample data and display the metadata that is part of any
\Rclass{TranscriptDb} object.

<<transcripts0>>=
samplefile <- system.file("extdata", "UCSC_knownGene_sample.sqlite",
                          package="GenomicFeatures")
txdb <- loadFeatures(samplefile)
txdb
@

\subsection{Working with Basic Features}

The most basic operations on a \Rclass{TranscriptDb} object are
retrieval of the genomic coordinates or \textit{ranges} for exons,
transcripts or coding sequences.  The functions
\Rfunction{transcripts}, \Rfunction{exons}, and \Rfunction{cds} return
the coordinate information as a \Rclass{GRanges} object.

For example, all transcripts present in a \Rclass{TranscriptDb} object
can be obtained as follows:

<<transcripts1>>=
GR <- transcripts(txdb)
GR[1:3]
@

%% FIXME: some discussion of the output GR[1:3] displays would be helpful.

The \Rfunction{transcripts} function can also be used to retrieve a
subset of the transcripts such as those on the $+$-strand of
chromosome 1.

<<transcripts2>>=
GR <- transcripts(txdb, vals <- list(tx_chrom = "chr1", tx_strand = "+"))
length(GR)
unique(strand(GR))
@

The \Rfunction{exons} and \Rfunction{cds} functions can be used in a
similar fashion to retrive genomic coordinates for exons and coding
sequences.

\subsection{Working with Grouped Features}
%% FIXME: reword this to be more concise

Often it will not be enough to just get exons, cds or transcripts
only.  Sometimes you will want to give greater consideration to the
context of the data.  In these cases, you will want to think of the
ranged annotation data as being grouped in a specific way, for
example, you might want to consider that the transcripts are each
associated with a specific gene or the exon composition of specific
transcripts. These relationships are maintained with
\Rclass{TranscriptDb} objects and can be accessed through the
\Rfunction{transcriptsBy}, \Rfunction{exonsBy}, and \Rfunction{cdsBy}
functions.

So for example, to extract all the transcripts grouped by their exons
you can call:

%% FIXME: it would help to provide a list of the available ``by''
%% arguments: gene, tx, ..., ???

<<transcriptsBy>>=
GRList <- transcriptsBy(txdb, "gene")
length(GRList)
names(GRList)[10:13]
GRList[[12]]
@

%% FIXME: consider some explanation of the GRangesList output

Similarly, to extract all the exons for each transcript you can call:

<<exonsBy>>=
GRList <- exonsBy(txdb, "tx")
length(GRList)
names(GRList)[10:13]
GRList[[12]]
@

These functions return \Rclass{GRangesList} objects that contain
locations and identifiers grouped according to the type of feature
specified. These objects can be used in downstream analyses such as
using \Rfunction{findOverlaps} contextualize the alignments from
high-throughput sequencing.

It is important to consider the context created when grouping by a
particular feature.  For example, in the first example, where we grouped
by genes, the name of the features is an Entrez Gene ID.  If the
database had been based instead on Ensembl sources, it would be an
Ensembl Gene ID.  However, in the second example where we group by
transcript, we see that the groups are labeled by an ID that is not a
traditional transcript ID.  In this second case, we have been given an
internally assigned database ID. This is because some sources may
choose to overload their use of traditional transcript IDs in ways
that would make the existence of our database schema impossible.  So
in the second case we have to use an internal id to guarantee
uniqueness.  This will happen whenever you group by anything that is
not a gene.  So when you want to use traditional transcript IDs you
can look them up using the appropriate basic accessors described in
the preceding section.

Another case where context can matter is when considering the order of
the elements returned.  In most cases the grouped elements will be
listed in the order that they occur along the chromosome.  But in the
context where you have grouped exons or CDS by transcripts, they will
instead be grouped according to their position along the transcript
itself.  This is important because alternative splicing can mean that
the order along the transcript can be different from that along the
chromosome.

\subsection{Prespecfied grouping functions}

The \Rfunction{intronsByTranscript}, \Rfunction{fiveUTRsByTranscript}
and \Rfunction{threeUTRsByTranscript} are convenience functions the
provide behavior equivalent to the grouping functions, but in
prespecified form. These functions return a \Rclass{GRangesList}
object grouped by transcript for introns, 5' UTR's, and 3' UTR's,
respectively.

<<introns-UTRs>>=
length(intronsByTranscript(txdb))
length(fiveUTRsByTranscript(txdb))
length(threeUTRsByTranscript(txdb))
@

\subsection{Convenience functions for computing overlap}

The \Rfunction{transcriptsByOverlaps}, \Rfunction{exonsByOverlaps} and
\Rfunction{cdsByOverlaps} functions return a \Rclass{GRangesList} object
containing data about transcripts, exons, or coding sequences that
overlap genomic coordinates specified by a \Rclass{GRanges}
object.
%%

%% FIXME: this ends up with zero ranges, is that really what we want?
%% Seems like it makes for a bad example.
<<transcriptsByOverlaps>>=
library("org.Mm.eg.db")
set.seed(430L)
idx <- sample(length(org.Mm.egCHRLOC), 50)
tbl <- unique(merge(toTable(org.Mm.egCHRLOC[idx]),
                    toTable(org.Mm.egCHRLOCEND[idx])))
gr <- with(tbl, {
    lvls <- paste("chr", c(1:19, "X", "Y", "MT", "Un"), sep="")
    GRanges(seqnames=factor(paste("chr", Chromosome, sep=""),
                            levels=lvls),
            ranges=IRanges(abs(start_location), abs(end_location)),
            strand=ifelse(start_location >= 0, "+", "-"),
            egid=gene_id)
})
transcriptsByOverlaps(txdb, gr)
@

The convenience functions can be a great shortcut, but because they
have to make assumptions about how the results are compared and
represented, they are ultimately not as flexible as just using the
basic and grouping accessors in combination with
\Rfunction{findOverlaps}.


\section{Example using RNA-seq data}
Let's suppose that you have run an experiment. After mapping all your
reads to a genome and collapsing them into a set of ranges, you want
to find out which genomic features a particular range overlaps with.
How would be the usual way to proceed?  Here is an example:

Let's consider the case where you have some RNA-seq data and you want
to convert your ranges into counts representing how hits per
transcript.  For this example, let's also assume that you are only
interested in counting ranges that overlap with exons (not introns).

First lets say that this is your data:
<<RNASEQ1, eval=FALSE>>=
gr <- GRanges(
    seqnames = rep("chr5",4),
    ranges = IRanges(start = c(244620, 244670, 245804, 247502),
                     end = c(244652, 244702, 245836, 247534)),
    strand = rep("+", 4))
@

From our \Rclass{TranscriptDb} object, we want to recover the annotations for
all of the relevant exons, but grouped according to their transcripts.
Therefore, we want to use \Rfunction{exonsby} and group them by transcripts.

<<exonsGroupedByTx>>=
annotGr <- exonsBy(txdb, "tx")
@

Then we need to used \Rfunction{findOverlaps} to learn which of our
data ranges, \Robject{gr}, will overlap with the in exons that we have
grouped by transcripts.

<<findOverlaps>>=
OL <- findOverlaps(annotGr, gr)
@

Finally, once we have called \Rfunction{findOverlaps} we can subset
out the annotations that meet our criteria.  The
\Rfunction{subjectHits} method will allow us to retrieve only the
things that overlapped with the subject in our original
\Rfunction{findOverlaps} call. And once we have subsetted out
annotations in this way, the length of the resulting
\Rclass{GRangesList} object is also the number of transcripts that
overlap with our data.

<<getAnswers>>=
tdata <- annotGr[subjectHits(OL),]
tdata

length(tdata)
@

By using \Rfunction{findOverlaps} along with the different accessors
in this way, it is possible to connect any data that has been
represented as a \Rclass{GRanges} object with the annotations stored in
a \Rclass{TranscriptDb} object.  Calling \Rfunction{findOverlaps} along
with the appropriate \Rclass{GRanges} object not only allows users to
quickly determine what has overlapped, but also controls what
criteria are used for determining whether an overlap has occurred.
This can be done by passing in an alternate \Rfunarg{type} parameter to
\Rfunction{findOverlaps}.  In addition, because the basic accesors allow
for the users to retrieve data grouped in different ways, the user has
control over which parts of a transcript or gene are included in the
overlap.


\section{Session Information}

<<SessionInfo, echo=FALSE>>=
sessionInfo()
@

\end{document}
