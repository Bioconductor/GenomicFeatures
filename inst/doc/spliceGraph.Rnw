%\VignetteIndexEntry{Representing Transcripts as Splice Graphs}
%\VignetteKeywords{annotation}
%\VignettePackage{GenomicFeatures}
\documentclass[11pt]{article}

\usepackage{url}
\usepackage{float}

\newcommand{\Rfunction}[1]{{\texttt{#1}}}
\newcommand{\Robject}[1]{{\texttt{#1}}}
\newcommand{\Rpackage}[1]{{\textit{#1}}}
\newcommand{\Rmethod}[1]{{\texttt{#1}}}
\newcommand{\Rfunarg}[1]{{\texttt{#1}}}
\newcommand{\Rclass}[1]{{\textit{#1}}}
\newcommand{\Rcode}[1]{{\texttt{#1}}}
\newcommand{\software}[1]{\textsf{#1}}
\newcommand{\R}{\software{R}}


\title{Generating Splice Graphs based on TranscriptDb Objects}
\author{Martin Morgan\and
  Marc Carlson \and
  Daniel Bindreither}


\SweaveOpts{keep.source=TRUE}

\begin{document}

\maketitle

<<results=hide, echo=FALSE>>=
reCnt <- FALSE
@ 


\section{Introduction}

The new \Rfunction{spliceGraph} function included into the 
\Rpackage{GenomicFeatures} package creates so-called splicing graphs \cite{Sammeth:2009:GB} 
based on annotation \Rclass{TranscriptDb} objects.
One use case for this function would be the analysis of an RNA-Seq experiment
on the transcriptome level.
As an analysis example we compare serious ovarian cancer (SOC) samples
from patients with benign samples from healthy individuals to find evidence for differential
expression of transcript variants and differential occurrence of the underlying
splicing mechanisms. Currently there exist several software
solutions for RNA-Seq based transcriptome analysis, like RSEM \cite{RSEM2011},
Cufflinks \cite{Roberts21062011} or the R
package \Rpackage{DEXSeq} \cite{Anders:2010:GB}.
Whereas \Rpackage{DEXSeq} offer the capability
to identify single differentially expressed exons, Cufflinks and RSEM focus on
the differential expression of whole transcript variants and new isoforms. 
This vignette provides a new perspective for analyzing RNA-Seq data
regarding alternative splicing mechanisms causing the variety
of already annotated transcript variants. The discussed approach may
also reveal advantages in counting reads on transcriptome annotations, 
which is usually a critical step in each RNA-Seq data analysis.


\section{Splicing graphs}

Alternative splicing is an frequently observed complex biological process which modifies
the primary RNA transcript and leads to transcript variants of genes.
These variants can often be plentiful, especially for large genes it
is usually a hard task to describe the full complexity of them in a formal, 
logical, short and convenient way. To capture the full variety of
splice variants in one common data structure per gene
Heber at al \cite{Heber01072002}
introduced the term splice graph and provided a formal frame work for representing
the different choices of the splicing machinery at a certain genomic
locus. This type of data structure provides also
some information about the underlying splicing mechanisms generating the
known annotated transcript variants captured by the splicing
graph. Different types of splicing mechanisms are
represented by splice codes which can be red out of the splicing graph
structure. 

Splicing graphs in general are directed acyclic graphs (DAGs) and
consist of two main structure elements designated as vertices and edges.
Vertices represent different types of sites at the annotated transcripts and
edges, connecting 
the vertices, represent the respective exonic and intronic structures.
Wether the edge is representing an exon or an intron is determined by the
types of the two flanking vertices. 
Vertices can be of type acceptor splice site ($-$), donor splice site
($\wedge$), transcript start site ($~[~$) or transcript end ($~]~$). 
For the correctness of the splicing graph framework artificial sites 
designated as root ($0$) and leaf ($1$) get attached to the start and the end of each
graph acting as a common source and a common sink of the graph.

It is important to note that root and leaf vertices will never represent 
real observed sites at the transcripts. The symbols associated with
the individual types of vertices shown in braces above are used for the splice code read out.
For details about this approach see 
\cite{Heber01072002} and \cite{Sammeth:2009:GB}.

Figure \ref{img:spliceGraph} shows the splice graph representation
of all transcript variants of gene JUNB (ENTREZ gene id 3726).
Before the splice graph is constructed the exons of the individual genes
respectively transcripts get disjoined to avoid overlapping sequence parts.
The green dashed lines in Figure \ref{img:spliceGraph}  represent
genomic locations 
where exons start, end or get disjoined during the splicing graph construction.
Due to disjoining new exons are created in such a way that none of
this new exons overlap each other.


\begin{figure}[H]
  \begin{center}
  \includegraphics[width=\textwidth]{3726-Txs.png}
  \end{center}
  \caption{Splice graph representation of the two transcript variants
    of the gene 3726 (JUNB) resulting in 2 bubbles. Left: splice graph
    representation. Right: transcript representation
  }
  \label{img:spliceGraph}
\end{figure}


\subsection{Advantages of disjoining}

As briefly mentioned in the introduction counting the reads landing on
the transcript annotations of a reference genome is a critical step
in each RNA-Seq analysis.
For performing a \Rpackage{DEXSeq} analysis counts landing on the individual
exons are required. One problem with counting reads on single
exons is that exons often consist only of few nucleotides and therefore
counting for this rather short sequences could be problematic. A
second problem arises if exons overlap each other, because it is not
ad-hoc clear to which one of two or more overlapping exons a read should be counted.
Software packages like RSEM and Cufflinks employ statistical models
for handling reads mapping to multiple transcript isoforms.
By using the splice graph approach the problem of counting reads
landing on overlapping exons of different transcript variants is not longer present
because the exons get disjoined for each gene. That is an improvement, but we
still have the problem of overlapping exons belonging to different genes.

Regrading the splicing graph structure disjoining of exons is revealing new
sites at the transcripts flagged with a $:$ symbol. Each site where disjoining occurs
can be considered as an intron of zero length
flanked by two vertices, one representing the
end of the first exon part (${\wedge}{:}$) and one representing the start of 
the second exon part (${-}{:}$). See also Figure \ref{img:spliceGraph}.


\subsection{Details about vertices and edges}

In some cases one vertex can represent two different types of sites, but
the combinations of types for such vertices is limited. 
Only splice site acceptors ($-$) and transcript start sites ($~[~$) or splice site
donors ($\wedge$) and transcript ends ($~]~$) can occur as a pair of
site types.
Such a two type vertex occurs when the start of an exon, which is not
the first exon of a transcript falls together with the
transcription start site of another transcript of the same gene.
A similar case occurs when the end of an exon, which is not the last
exon of a transcript falls together with the transcript
end of another transcript isoform belonging to the same gene. 
As mentioned above the edges can either represent introns or exons
depending on the types of the flanking vertices.
An edge between a splice site acceptor ($-$) and a splice site donor ($\wedge$) vertex
for example would represent an exon whereas the edge between an
splice site donor ($\wedge$) and an splice site acceptor ($-$) would represent an intron.
Exons are also described between transcription start sites ($~[~$) and splice
site donors ($\wedge$) or splice site acceptors ($-$) and transcript
ends ($~]~$). The edges between the root vertex ($0$) and the transcription start
sites ($~[~$) as well as the edges between the transcript 
ends ($~]~$) and the leaf ($1$) contain neither an
intron nor an exon because such edges contain usually no 
sequence information at all.

\subsection{Alternative splicing events form bubbles in the
  splicing graph}

Not all present sites on the individual transcripts are alternative splice sites.
Therefore the initial splicing graph outlined above can be simplified by collapsing 
vertices of in- and out- degree equal to one because they
are supposed to be non-informative, because no alternative choices of the splicing machinery
are recorded in the utilized annotations for them.
Edges associated with such vertices get also sequentially collapsed with
the previous ones and result in longer edges capturing several exons.
The final splicing graph only contains vertices where alternative
splicing is observed. Between two remaining vertices there exist at
least two edges which form a bubble and represent the two alternative
structures of the transcript partitions constrained by the two vertices.
Such bubbles can be nested or can intersect with other bubbles.
The collapsed edges of the final splicing graph associated with one or more exons 
which do not overlap each other form larger sequence regions providing advantages in
counting reads. 
The \Rfunction{spliceGraph} function returns the
collapsed edges with their associated disjoined exons and provides information
about the underlying splicing mechanisms represented as splicing codes.
Additionally the object contains also mapping of edges to the
individual bubbles and bubble parts.

\subsection{Interpretation of the splicing codes}
\label{sec:spliceCodes}

Splicing codes can be obtained by iterating over the individual
bubbles and collecting the 
types of the original vertices associated with the individual bubble
edges and their ranks. This section
makes use of simple toy examples to describe how the splicing code can be interpreted in terms of
well known splicing mechanisms like exon skipping, alternative promotor usage,
intron retention, etc.

One example read out of a bubble could reveal the splicing code ($1~0~0~2~1 - 2~2~\wedge$ ) 
which would represent an 1 exon skip. See Figure \ref{img:exskip}.
The first part of the code ($1~0~0$) indicates that the first edge
contains no exon at all. The first symbol of this code part
indicates the edge number, the second symbol the vertex rank within the bubble and the
third symbol the vertex type. The second part of the splice code ($2~1 - 2~2~\wedge$)
represents edge number 2 containing exactly one exon described by the flanking vertices
$-$ and $\wedge$. 



\begin{figure}[H]
  \begin{center}
  \includegraphics[width=\textwidth]{exskip.png}
  \end{center}
  \caption{Splice graph representation of an 1 exon skip leading to
    one bubble. The associated splice code is $1~0~0~2~1 - 2~2~\wedge$. Left: splice graph
    representation. Right: transcript representation
  }
  \label{img:exskip}
\end{figure}


Another example where disjoining comes into play is a
an alternative splice site acceptor in one of two transcripts.
The code for an alternative splice site acceptor would be $1~0~0~2~1 - 2~2~{\wedge}{:}$
and can be seen as an exon skip where the end of the exon is linked to
a disjoint site. In such a way it is possible to characterize and to
distinguish a variety of different splicing events. See Figure \ref{img:altaccept}


\begin{figure}[H]
  \begin{center}
  \includegraphics[width=\textwidth]{altaccept.png}
  \end{center}
  \caption{Splice graph representation of an alternative acceptor site
    leading to one bubble. The associated splice code is $1~0~0~2~1 - 2~2~{\wedge}{:}$. 
    Left: splice graph representation. Right: transcript representation
  }
  \label{img:altaccept}
\end{figure}

The next section describes how such graphs can be obtained in R 
and utilized for differential expression analysis.
Further downstream the information about observed splicing events
within the annotation is linked to the differentially expressed bubble edges.


\section{Creating the splicing graph}

As outlined in the previous section the splicing graph approach
extends the differential expression analysis of single exons
implemented by in \Rpackage{DEXSeq} towards
the analysis of a priori known alternative splicing events.
The starting point for creating a splice graph is a
\Rclass{TranscriptDb} object containing all required gene 
and transcript annotation of a certain reference genome.
Here the \Rpackage{TxDb.Hsapiens.UCSC.hg18.knownGene} package is used.

If other annotations are needed such objects can easily be
created by using functions of the \Rpackage{GenomicFeatures} package.

First we load the selected \Rclass{TranscriptDb} object.

<<loadTxdb>>=
library("TxDb.Hsapiens.UCSC.hg18.knownGene")
txdb <- TxDb.Hsapiens.UCSC.hg18.knownGene
@

Creating a splicing graph for the whole \Rclass{TranscriptDb}
object usually takes about 50 minutes if the information 
about the types of alternative splicing events is retrieved on a normal 
desktop computer. If only the edges of the splicing graph are retrieved
the computation time shortens to about 12 minutes for the 
whole \Rclass{TranscriptDb} object.
To save some time we utilize only chromosome 19. 
To run the \Rfunction{spliceGraph} function only on a subset of
the \Rclass{TranscriptDb} object the \Rpackage{GenomicFeatures}
package provides the \Rfunction{isActiveSeq} function
to deactivate chromosomes in the \Rclass{TranscriptDb} object which should
not be used. Usually one would deactivate strange
chromosome variants often found in the annotation.

<<deactChr>>=
activeChr <- ! isActiveSeq(txdb)
activeChr[names(activeChr) == "chr19"] <- TRUE
isActiveSeq(txdb) <- activeChr
@

Finally we can execute the \Rfunction{spliceGraph} function onto 
the \Rclass{TranscriptDb} object.
The function will return a \Rclass{GrangesList} object containing the
collapsed edges of the splicing graph, their associated exons and information
about the types of splicing events found in the annotation only for
chromosome 19.

<<loadGenomicFeatures>>=
library("GenomicFeatures")
sg <- spliceGraph(txdb)
@

Now we can have a look onto the resulting object. The provided
\Rclass{GrangesList} contains the edge IDs as list names.
The exons in the \Rclass{Granges} objects are not the original
exons provided by the \Rclass{TranscriptDb} object, since the gene
model became modified internally.
As mentioned in the previous section during the splicing graph 
construction overlapping exons within a gene get disjoined and
new exons with new exon ids which differ in
size compared to the original exons are produced.

The original exon ids associated with the new exon ids
can be found in the metadata column of the individual list elements
and is called \Rfunction{exon\_ids}. Each element of the
column is a \Rclass{CharacterList} containing the original exon ids.
The new disjoined exon ids can be retrieved
directly from  the metadata column called \Rfunction{disJ\_exon\_ids}.
As already mentioned in the introduction there is also information
provided about the splicing events generating the individual
transcript variants. This information is stored in the metadata slot
of the \Rclass{GrangesList} object and can be accessed by using the 
\Rfunction{metadata} function.

Below an example edge of the object returned by the \Rfunction{spliceGraph}
function is shown. This edge consist of multiple exons.

\begin{scriptsize}
<<exbyedges>>=
sg["1008"]
@ 
\end{scriptsize}

In the code chunk below we access the information about the type of
splice events and try to quantify them later on.

\begin{scriptsize}
<<spliceevents>>=
head(metadata(sg)$spliceEvents, n=2)
@ 
\end{scriptsize}

The types of alternative splice events are provided as a \Rclass{DataFrame}
object. The first column provides the so-called bubble code. The
bubble code assigns an unique identifier to the individual splice events
(bubbles) and consists basically of an bubble ID concatenated with the
ENTREZ gene ID. The second column provides
\Rclass{CompressedCharacterList}s representing the splice codes.
To explore the meaning of the code symbols go back to Section \ref{sec:spliceCodes}.
The last three columns provide the name of the splice event, the
corresponding ENTREZ gene ID and the bubble ID unique within each gene.

Back to quantifying the observed splice events in the 
annotation. Now we are interested which types of splice events occur most often.

<<bubbles>>=
spliceEvents <- metadata(sg)$spliceEvents
sp <- split(spliceEvents$bubbleCode, 
                     factor(spliceEvents$eventType))
eventSum <- data.frame(event=names(sp), Nr=elementLengths(sp),
                                row.names=NULL)
eventSum <- eventSum[order(eventSum$Nr, decreasing=TRUE), ]
@ 

We would expect that simple events occur more frequently than
complex events.

<<splicEventSum>>=
head(eventSum)
@ 

The most often occurring splice event on chromosome 19 is named skip
one exon. At this point it should be mentioned that not all splice
events have names since there are a variety of different events. How many
different events do we actually observe at chromosome 19? Lets check this.

<<varietyOfEvents>>=
allEvents <- lapply(spliceEvents$code, paste, collapse=" ")
allEvents <- unlist(allEvents, use.names=FALSE)
nrOfdiffEvents <- length(unique(allEvents))
nrOfdiffEvents
@ 

We observe \Sexpr{nrOfdiffEvents} different events only on
chromosome 19. So everybody can imagine that we have not given to all
those events names. So don't be surprised if some NAs show up.

To have a look onto the dependency
of the occurrence of events on their complexity we create a log plot
showing the number of symbols for each unique events plotted against
the occurrence frequency.

<<freqEvents, results=hide>>=
events <- factor(unlist(allEvents, use.names=FALSE))
occurance <- tabulate(events)
idx <- !duplicated(unlist(allEvents, use.names=FALSE))
uniCodes <- spliceEvents$code[idx]
size <- elementLengths(uniCodes)

fn <- "power-law.png"
png(fn,  width=7, height=7, res=300, units="in")
plot(log(size), log(occurance), frame.plot=FALSE, pch=16, 
     cex=0.7, xlab="log( size of alternative splicing events )", 
     ylab="log( frequency of alternative splicing events )",
     main="Complexity of splice events (Chr 19)")
dev.off()
@ 

Figure \ref{img:powerLaw} shows a slight relation ship of the size of the
splice events with there occurrence frequency. This plot confirms that
smaller events occur more often than larger ones. This is what we
already expected.

\begin{figure}[H]
  \begin{center}
    \includegraphics[width=0.8\textwidth]{\Sexpr{fn}}
  \end{center}
  \caption{Occurrence of alternative splice events and their relation
    ship to the size of the events.
  }
  \label{img:powerLaw}
\end{figure}

Another interesting information which we can gain from the splice
graph is how many splice events does each individual gene have.
To address this issue we have to count the number of bubbles within
each gene.

<<>>=
idx <- ! duplicated(spliceEvents$bubbleCode)
nrOfBubs <- elementLengths(split(spliceEvents$bubbleCode[idx], 
                                 spliceEvents$gn[idx]))
nrOfBubs <- nrOfBubs[order(nrOfBubs,decreasing=TRUE)]
@ 

Below the genes with the most observed splice events are shown.

<<>>=
head(nrOfBubs)
@ 

Next we want to see which genes show the highest heterogeneity of splice events.
We check for the number of unique splice events for each gene.

<<>>=
uniEventsPerGn <- lapply(split(allEvents, spliceEvents$gn), 
                         unique)
nrOfUniEvents <- elementLengths(uniEventsPerGn)
nrOfUniEvents <- nrOfUniEvents[order(nrOfUniEvents, 
                                     decreasing=TRUE)]
@ 

Below the genes with the highest heterogeneity in observed splice events
are shown

<<>>=
head(nrOfUniEvents)
@ 

\subsection{Mapping of edge elements to genes and exons}

To get a mapping of the original exons to the new disjoined exons 
the exons by edge object have to be unlisted first. 
From the flat \Rclass{Granges} object we can then easily retrieve the 
original exon ids. For the mapping we utilize a simple
\Rclass{data.frame} object because the mapping between the new disjoined
exon ids and the original exon ids is ambiguous.

<<origExToDJEx>>=
sg.flat <- unlist(sg, use.names=FALSE)
orig.Ex <- values(sg.flat)[["exon_ids"]]
disJ.Ex <- values(sg.flat)[["disJ_exon_id"]]

newExNames <- rep(disJ.Ex, elementLengths(orig.Ex))
origExToNewEx <- data.frame(orig.Ex=unlist(orig.Ex), 
                            disJ.Ex=newExNames, 
                            row.names=NULL)

head(origExToNewEx)
@

The gene ids are directly retrievable from the \Rclass{GrangesList}
object. To get the
gene ids the \Rfunction{values} accessor function is used.
The mapping from edges to genes is used further downstream in the analysis.

<<getGeneToEdge>>=
gnIDs <- values(sg)[["gene_id"]]
edgeIDs <- names(sg)
gnToEdge <- setNames(gnIDs, edgeIDs)
@ 


The next step we want to perform is use the information computed above
in terms of RNA-Seq and transcriptome analysis.

\section{Counting reads}

This section deals with counting the reads associated with the
individual edges. To elucidate later in this vignette some
advantages of the splice graph approach the reads for the original 
exon structure get also counted.

Counting can be done in different ways. Here we use
the \Rfunction{summarizeOverlaps} function of the \Rpackage{GenomicRanges}
package with default settings.

As a starting point for counting the aligned reads are required.
The aligned reads used in this example are stored as BAM files. 
The BAM files used for counting reads are not
provided since they would exceed the
usual size of an R package. The code below is therefore only an example
code which should not be executed since the BAM files are lacking.

First the location of the BAM files used in here is specified .
The BAM files one to three in this directory are
the reads of the benign samples and the BAM files 62 to 64 contain the
the selected SOC samples. The \Rfunction{summarizeOverlaps} function 
requires a \Rclass{BamFileList} object which is created out of the
the file paths to the six selected BAM files.

<<countingReads>>=
if(reCnt) {
  require("Rsamtools")
  bamPath <- "/shared/labs/EDI/users/mfitzgib/Solexa"
  fls <- sub(".bai$", "", 
             list.files(bamPath, recursive=TRUE,
                        pattern="accepted_hits.*bai$", 
                        full=TRUE))
  fls <- fls[c(1:3, 62:64)]
  bfs <- BamFileList(fls)
  names(bfs) <- 
    gsub("/shared/labs/EDI/users/mfitzgib/Solexa/tophat_",
         "",fls)
}
@ 

\subsection{Counting reads per edges}

The reads get counted based on the edge model created above.
The \Rfunction{summarizeOverlaps} function reduces first
adjacent elements of an edge to one larger range before the counting
is done.

Counting is performed for each BAM file separately and can be
parallelized to save computation time. After counting the
count table contains one row for each edge.

<<CountReads>>=
if(reCnt) {
  library(parallel)
  resEx.byEdge <- 
    summarizeOverlaps(features = sg, reads = bfs,
                      mc.cores = getOption("mc.cores", 3L))
  
  cD.exByEdge <- assays(resEx.byEdge)$counts
  colnames(cD.exByEdge) <- 
    sub("/accepted_hits.bam", "", colnames(cD.exByEdge))
  save(cD.exByEdge, file="cD.exByEdge-SG-Vig.Rda")
} else {
  fn <- system.file("extdata", "cD.exByEdge-SG-Vig.Rda", 
                    package="GenomicFeatures")
  load(fn)
}
@ 

\subsection{Counting reads per exons}

Since the properties of the splicing graph structure should be compared 
to the properties of the exon structure, reads get also counted for
the exon model.
To ensure fairness all exons used in the edge model should 
be also present in the exon model. The exon model can be easily
retrieved from the \Rclass{TranscriptDb} object and subset to the
original exons used for creating the edge model.
Duplicated exons get removed, because they would influence the
exon counting process.

<<readsPerEx>>=
exsByGenes <- exonsBy(txdb, "gene")
gnToEx <- rep(names(exsByGenes), elementLengths(exsByGenes))
exsByGenes.flat <- unlist(exsByGenes, use.names=FALSE)

# remove duplicates
notDupl <- !duplicated(values(exsByGenes.flat)[["exon_id"]])
exsByGenes.flat <- exsByGenes.flat[notDupl]
names(exsByGenes.flat) <- values(exsByGenes.flat)[["exon_id"]]
gnToEx <- gnToEx[notDupl]
names(gnToEx) <- names(exsByGenes.flat)
@ 

For performing the comparison edge versus exon model a exons to genes map
is required. Such a map was already created above called \Rfunction{gnToEx}.
Now we are ready for counting the reads of the exon model.
Counting is performed in the same way as for the edge model.
Last we create a exon count table.

<<edgeVsEx>>=
if(reCnt) {
  res.exsByGenes <- 
    summarizeOverlaps(features = exsByGenes.flat, reads = bfs,
                      mc.cores = getOption("mc.cores", 3L))

  cD.exsByGenes <- assays(res.exsByGenes)$counts
  colnames(cD.exsByGenes) <- 
    sub("/accepted_hits.bam", "", colnames(cD.exsByGenes))
  save(cD.exsByGenes, file="cD.exsByGenes-SG-Vig.Rda")
} else {
  fn <- system.file("extdata", "cD.exsByGenes-SG-Vig.Rda", 
                    package="GenomicFeatures")
  load(fn)
}
@ 

The final result of this section are the two count tables which
contain the read counts per exons and the read counts per edges. 


\section{Testing for differentially expressed edges}

This section deals with testing for differential expression of the individual edges 
and exons. In general genes can consist of one edge or of more than
one edge. The same is true for the exons, because there might be also some
short genes containing only one single exon. This facts are crucial for performing
differential expression analysis in the right way. The working strategy is to use
the \Rpackage{DEXSeq} package for genes with multiple
exons or edges and the \Rpackage{DESeq} package for genes with only
one edge or exon. We would expect much more single edge genes
than single exon genes because edges can consist of several exons. 

Chromosome 19 has \Sexpr{dim(cD.exByEdge)[1]} edges and 
\Sexpr{dim(cD.exsByGenes)[1]} exons.
Now as an initial part of the comparison of the exons versus the edges
approach we want to find out how many
single exon genes and single edge genes we actually have.

<<prepDiffExp>>=
edIds <- names(sg)
gnIds.edges <- gnToEdge[rownames(cD.exByEdge)]
nrOfEdgesPerGns <- 
  elementLengths(split(edIds, factor(gnIds.edges)))
sglEdgeGns <- names(nrOfEdgesPerGns)[nrOfEdgesPerGns < 2]

exIds <- names(exsByGenes.flat)
gnIds.exs <- gnToEx[names(exsByGenes.flat)]
nrOfExsPerGns <- 
  elementLengths(split(exIds, factor(gnIds.exs)))
sglExGns <- names(nrOfExsPerGns)[nrOfExsPerGns < 2]
@ 

We have \Sexpr{length(sglExGns)} single exon genes and 
\Sexpr{length(sglEdgeGns)} single edge genes. 
Single element genes get tested for differential expression by 
utilizing the \Rpackage{DESeq} package.
For the other genes with multiple edges and multiple exons 
\Rpackage{DEXSeq} is utilized.

<<subsetCounts>>=
cD.exByEdge <- cD.exByEdge[, colnames(cD.exsByGenes)]
@ 

\subsection{DEXSeq analysis for multi element genes}

The initial step for each differential expression analysis is to set up the 
design of the experiment. Basically we are interested in comparing tumor samples
with benign samples. This means we have a three against three design and
therefore for each condition three biological replicates.

<<DEXSeq>>=
benign <- grepl("Benign",colnames(cD.exByEdge ) )
design <- factor(ifelse(benign, "Benign", "SOC"), 
                 levels=c("Benign", "SOC"))
names(design) <- ifelse(benign, "Benign", "SOC")

design
@ 

Below exon and edge count data sets required for the \Rpackage{DEXSeq} analysis 
are created. For details about \Rpackage{DEXSeq} see the \Rpackage{DEXSeq} package
vignette. Before the element count data sets are finally created we have to
prepare annotation information which is in principle not needed for
performing the analysis itself,
but is essential to create nice plots of top candidate genes afterwards. 

The code below extracts the start and end coordinates of each edge and orders
the edges according to their genomic starting position.

<<resDexSeq, results=hide>>=
sg.flat <- unlist(sg, use.names=FALSE)
edgeIDs <- rep(names(sg), elementLengths(sg))
rle <- strand(sg.flat)
start <- start(sg.flat)
end <- end(sg.flat)

temp <- data.frame(start, end, edgeIDs, 
                   strand=rep(rle@values, rle@lengths),
                   chr=rep(seqnames(sg.flat)@values, 
                     seqnames(sg.flat)@lengths))


temp <- temp[order(temp$edgeIDs, -temp$end), ]
end <- temp$end[!duplicated(temp$edgeIDs)]
names(end) <- temp$edgeIDs[!duplicated(temp$edgeIDs)]

temp <- temp[order(temp$edgeIDs, temp$start), ]
edgeAnnot <- temp[!duplicated(temp$edgeIDs),]
rownames(edgeAnnot) <- edgeAnnot$edgeIDs
edgeAnnot$end <- end[rownames(edgeAnnot)]

edgeAnnot <- edgeAnnot[order(gnToEdge[edgeAnnot$edgeIDs], 
                             edgeAnnot$start), ]
@ 

T contains now all required edge annotation information and we can
create a \Rfunction{newExonCountSet}. The ordering of the edges in the
annotation information \Rclass{data.frame} should be the same as in
the count table. After creating the \Rclass{ExonCountSet} we subset to
genes containing multiple edges.

<<newData,results=hide>>=
library(DEXSeq)
cd.tmp <- cD.exByEdge[edgeAnnot$edgeIDs,]
gn.tmp <- factor(gnToEdge[edgeAnnot$edgeIDs])
rownames(cd.tmp) <- paste(gn.tmp, rownames(cd.tmp), sep=":")
ex.tmp <- edgeAnnot$edgeIDs
names(ex.tmp) <- rownames(cd.tmp)
names(gn.tmp) <- rownames(cd.tmp)
rownames(edgeAnnot) <- rownames(cd.tmp)

eData.Edge <- 
  newExonCountSet(countData = cd.tmp ,
                  design = design,
                  geneIDs = gn.tmp,
                  exonIDs = ex.tmp,
                  exonIntervals = edgeAnnot)
idx <- ! gnToEdge[edgeAnnot$edgeIDs] %in% sglEdgeGns
             

eData.Edge <- eData.Edge[idx, ]
@ 

The same procedure performed for the edges is also done for the exons.
The code below extracts the start and end coordinates of each exon.

<<table>>=
exAnnot <- data.frame(chr=rep(seqnames(exsByGenes.flat)@values, 
                  seqnames(exsByGenes.flat)@lengths), 
                start=start(exsByGenes.flat), 
                end=end(exsByGenes.flat), 
                strand=rep(strand(exsByGenes.flat)@values, 
                  strand(exsByGenes.flat)@lengths),
                row.names=values(exsByGenes.flat)[["exon_id"]])
@ 

exAnnot contains now all required exon annotation information and we can
create a \Rfunction{newExonCountSet}. The ordering of the exons in the
annotation information \Rclass{data.frame} should be the same as in
the count table. After creating the \Rclass{ExonCountSet} we subset to
genes containing multiple exons.
                
<<qqq>>=
cd.tmp <- cD.exsByGenes
gn.tmp <- factor(gnToEx[rownames(cD.exsByGenes)])
rownames(cd.tmp) <- paste(gn.tmp, rownames(cd.tmp), sep=":")
ex.tmp <- rownames(cD.exsByGenes)
names(ex.tmp) <- rownames(cd.tmp)
names(gn.tmp) <- rownames(cd.tmp)
anno.tmp <- exAnnot[rownames(cD.exsByGenes),]
rownames(anno.tmp) <- rownames(cd.tmp)

eData.Ex <- 
  newExonCountSet(countData = cd.tmp,
                  design = design,
                  geneIDs = gn.tmp,
                  exonIDs = ex.tmp,
                  exonIntervals=anno.tmp)
eData.Ex <- 
  eData.Ex[! gnToEx[rownames(cD.exsByGenes)] %in% sglExGns, ]
@ 

Next we compute the size factors of the individual libraries, estimate
the dispersion and fit the dispersion function for both count data
sets. Then we test for differential expression and estimate the fold
changes. Last we create a top table for both sets. Keep in mind that \Rpackage{DEXSeq}
discards by default row elements in the count tables which have less than
11 counts across all samples. \Rpackage{DEXSeq} also doesn't test genes
which have more than 70 exons or edges.

Run the analysis for the exon count data set.

<<ttEx, results=hide>>=
eData.Ex <- estimateSizeFactors(eData.Ex)
eData.Ex <- estimateDispersions(eData.Ex)
eData.Ex <- fitDispersionFunction(eData.Ex)
eData.Ex <- testForDEU(eData.Ex)
eData.Ex <- estimatelog2FoldChanges(eData.Ex)
tt.Ex <- DEUresultTable(eData.Ex)
@ 

Run the analysis for the edge count data set.

<<ttEdge, results=hide>>=
eData.Edge <- estimateSizeFactors(eData.Edge)
eData.Edge <- estimateDispersions(eData.Edge)
eData.Edge <- fitDispersionFunction(eData.Edge)
eData.Edge <- testForDEU(eData.Edge)
eData.Edge <- estimatelog2FoldChanges(eData.Edge)
tt.Edge <- DEUresultTable(eData.Edge)
@ 

First we want to compare the estimated dispersion for both cases.
Figure \ref{img:DispPlots} shows the resulting plot. The dispersion
estimates look quite similar.

<<plots, results=hide>>=
plotDisp <- function(eData, case="") {
  meanvalues <- rowMeans(counts(eData))
  plot(meanvalues, fData(eData)$dispBeforeSharing, 
       main = paste(case, " mean vs CR dispersion", sep=":"), 
       frame.plot=FALSE, pch=16, cex=0.8, log = "xy",
       ylab="Dispersion", xlab="Mean counts")
  x <- 0.01:max(meanvalues)
  y <- eData@dispFitCoefs[1] + eData@dispFitCoefs[2]/x
  lines(x, y, col = "purple", lwd=2)
}

fn <- "Disp-plots.png"
png(fn,  width=11, height=5.5, res=300, units="in")
par(mfrow=c(1,2))
plotDisp(eData.Ex, "Exons")
plotDisp(eData.Edge, "Edges")
dev.off()
@ 


\begin{figure}[H]
  \begin{center}
    \includegraphics[width=\textwidth]{Disp-plots.png}
  \end{center}
  \caption{Dispersion estimates.
    Left: classic exon model. Right: splicing graph edge model
  }
  \label{img:DispPlots}
\end{figure}


\subsection{DESeq analysis for single element genes}

In this section the \Rpackage{DESeq} analysis of the single
edge and single exon genes is performed. First we create count data sets
and set up the testing conditions for the differential expression analysis.

<<se, results=hide>>=
library(DESeq)
cds.Ex <- newCountDataSet(countData=cD.exsByGenes, 
                          conditions=design)
cds.Ex <- cds.Ex[gnToEx[rownames(cD.exsByGenes)] %in% sglExGns,]

sel <- gnToEdge[rownames(cD.exByEdge)] %in% sglEdgeGns

cds.Edge <- newCountDataSet(countData=cD.exByEdge[sel,], 
                            conditions=design)
@ 


Next we compute the size factor, estimate the dispersion and test for
differentially expression for both sets of single elements

Test for differential expression of single exon genes.

<<difExEx>>=
cds.Ex <- estimateSizeFactors( cds.Ex )
cds.Ex <- estimateDispersions( cds.Ex )
ttSingle.Ex <- nbinomTest( cds.Ex,"SOC", "Benign" )
@ 

Test for differential expression of single edge genes.

<<diffExEdge>>= 
cds.Edge <- estimateSizeFactors( cds.Edge )
cds.Edge <- estimateDispersions( cds.Edge )
ttSingle.Edge <- nbinomTest( cds.Edge,"SOC", "Benign" )
@ 

Now the differential expression analysis for all elements is completed.
As a last step the results of the \Rpackage{DEXSeq} and the \Rpackage{DESeq}
analysis are combined into one common top table containing the fold
changes and their associated p-values.

<<DexSeqSum>>=
int.DEXSeq <- c("exonID", "pvalue", "padjust", 
                "meanBase", "log2fold(SOC/Benign)")
int.DESeq <- c("id", "pval", "padj", "baseMean", 
               "log2FoldChange")

temp <- tt.Edge[, int.DEXSeq]
colnames(temp) <- int.DESeq
finTT.Edge <- rbind(ttSingle.Edge[, int.DESeq], temp)
finTT.Edge$gnID <- gnToEdge[finTT.Edge$id]

temp <- tt.Ex[, int.DEXSeq]
colnames(temp) <- int.DESeq
finTT.Ex <- rbind(ttSingle.Ex[, int.DESeq], temp)
finTT.Ex$gnID <- gnToEx[finTT.Ex$id]
@ 

Now we have a look onto the individual top tables to see if there are
some genes in common between the exon model results and the edge 
model results.


\section{Comparing the edge and the exon models}

This section deals with comparing the results of the exon model
approach with the results of the edge model approach. 
The aim of utilizing the splicing
graph methodology was to get more robust results and to increase the statistical power
of the tests for differential expression.
Remember that before constructing the splicing graph some of the
exons got disjoined in smaller non-overlapping parts, when overlapping exons of
the same gene where present. By just using the original exon structure,
still containing overlapping parts of exons, the counting process would discard
reads which map to those parts because of their ambiguousness.
The first indication for which method could be more appropriate is to retrieve the
total number of raw counts of the exons count table and the edges count table.

<<compEdgeEx>>=
sum(cD.exByEdge)
sum(cD.exsByGenes)
sum(cD.exsByGenes*100)/sum(cD.exByEdge)
@ 

The comparison of the raw counts reveals that the exon count table
contains about 30\% fewer counts than the edge count table. 
Regarding the total number of counts it seems that using the splicing
graph approach leads to some improvement. But what does this mean for
the differential expression analysis. Does more counts provide more robust
results?  What about the number of differentially expressed elements?

To gain more insight into this issue
mean expression versus fold change plots are created to visualize the
differences in expression of the individual edges and exons 
between SOC samples and benign samples. See Figure \ref{img:MAPlots}
for the resulting plot. By considering the fold change region about -4
in both plots it is noticeable that the proportion of
significant edges to nonsignificant edges is higher than the
proportion of significant exons to nonsignificant exons.
This in turn could be an indication for more robust results.

<<MAplots,results=hide>>=
fn <- "MA-plots.png"
png(fn,  width=11, height=5.5, res=300, units="in")
par(mfrow=c(1,2))
plot(finTT.Ex$baseMean, finTT.Ex$log2FoldChange, log = "x",
     col = ifelse(finTT.Ex$padj < 0.1, "purple", "black"), 
     ylim = c(-5, 5), main = "Exons MvsA", pch=16, cex=0.7, 
     frame.plot=FALSE)
plot(finTT.Edge$baseMean, finTT.Edge$log2FoldChange,
     col = ifelse(finTT.Edge$padj < 0.1, "purple", "black"), 
     ylim = c(-5, 5), main = "Edges MvsA", pch=16, cex=0.7, 
     log = "x", frame.plot=FALSE)
dev.off()
@ 


\begin{figure}[H]
  \begin{center}
    \includegraphics[width=\textwidth]{MA-plots.png}
  \end{center}
  \caption{Mean expression vs log2 fold change plot, significant ($p < 0.1$) hits are colored in purple.
    Left: classic exon model. Right: splicing graph edge model
  }
  \label{img:MAPlots}
\end{figure}

Next we want to see which percentage of exons and edges is significantly 
differentially expressed between SOC samples and benign samples.

<<sigDiff>>=
ex.test <- nrow(finTT.Ex)
edge.test <- nrow(finTT.Edge)

sig.diff.ex <- sum(finTT.Ex$padj < 0.05, na.rm=TRUE)
sig.diff.edge <- sum(finTT.Edge$padj < 0.05, na.rm=TRUE)

sig.diff.ex*100/ex.test
sig.diff.edge*100/edge.test
@ 

To visualize the final results of the edges versus exons comparison
we create a plot where
different p-value cut offs are plotted against the associated number of
significantly differentially expressed exons and edges.

<<pcutSum, results=hide>>=
p.cuts <- 10^seq( 0, -5, length.out=100 )

ps.Ex <- sapply(p.cuts, function(p.cut) {
  sum(finTT.Ex$pval < p.cut, na.rm=TRUE)*100/
    length(finTT.Ex$pval)
})

ps.Edge <- sapply(p.cuts, function(p.cut) {
  sum(finTT.Edge$pval < p.cut, na.rm=TRUE)*100/
    length(finTT.Edge$pval)
})


fn <- "Comparison-edges-exons.png"
png(fn,  width=7, height=7, res=300, units="in")
plot(ps.Edge, p.cuts, type="l", col="purple",
     xlab="% of differentially expressed elements",
     ylab="P-value cut off", lwd=2, frame.plot=FALSE, 
     log="xy", main="Exons versus edges")
lines(ps.Ex, p.cuts, lty=2, lwd=2)
grid(lwd=2)
legend("bottomright", legend=c("Edges", "Exons"), 
       col=c("purple", "black"), lty=c(1,2), lwd=2,
       border=NA, box.col=NA, bg=NA)
dev.off()
@ 

Figure \ref{img:ComparisonDEA} shows the comparison of both approaches
regarding the percentage of significantly differentially expressed elements.
By looking onto the characteristics of the curves it seems that the splice 
graph edges approach provides more
statistical power than the classic \Rpackage{DEXSeq} approach.

\begin{figure}[H]
  \begin{center}
    \includegraphics[width=0.8\textwidth]{Comparison-edges-exons.png}
  \end{center}
  \caption{Comparison of differential expression results of edges
    versus exons.
  }
  \label{img:ComparisonDEA}
\end{figure}

Table \ref{table:ex} and Table \ref{table:edge} show the 10 most
significant differentially expressed edges and exons. The most promising hit 
common in both top tables is ENTREZ gene id 90522 (YIF1B, Yip1 interacting factor homolog B). 
This protein is a multi-pass membrane protein, but there is not much known about 
its function. However it just serves as an example in here.

<<pp, results=tex, echo=FALSE>>=
library(xtable)
T <- xtable(head(finTT.Ex[order(finTT.Ex$padj),], n=10), 
            caption="Top table of the exon model", label="table:ex",
            display=c("s","d","E","E","f","f","d"))
print(T, include.rownames=FALSE, table.placement="H")
@ 

<<rr, results=tex, echo=FALSE>>=
library(xtable)
T <- xtable(head(finTT.Edge[order(finTT.Edge$padj),], n=10), 
            caption="Top table of the edge model", label="table:edge",
            display=c("s","d","E","E","f","f","d"))
print(T, include.rownames=FALSE, table.placement="H")
@ 

Last we want to have a look on the individual counts of the elements
of ENTREZ gene 90522 (YIF1B). For visualizing the counts of this gene we use
the plot routines of the \Rpackage{DEXSeq} package.

<<ww, results=hide>>=
plotExp <- function(fn, eDat) {
  png(fn,  width=11, height=5.5, res=300, units="in")
  par(mfrow=c(1,2))
  COL <- c("#3399FF", "#FF3333")
  plotDEXSeq(eDat, geneID="90522", cex.axis = 1.2, cex = 1.3,
             lwd = 2, legend = TRUE, color=COL, 
             color.samples=COL[design], splicing=TRUE)
  plotDEXSeq(eDat, geneID="90522", expression = FALSE, 
             norCounts = TRUE, cex.axis = 1.2, cex = 1.3, 
             lwd = 2, legend = TRUE,
             color=COL, 
             color.samples=COL[design], splicing=TRUE)
  dev.off()
}

fn <- "Edge-plot.png"
plotExp(fn, eData.Edge)
fn <- "Ex-plot.png"
plotExp(fn, eData.Ex)
@ 

Figure \ref{img:EdgePlot} and \ref{img:ExPlot} show the normalized
count data for the splice graph edges model and for the classic exons model.
Also the corresponding edges and exons model is shown. In the case of 
gene 90522 (YIF1B) both approaches come to the similar results, but
it is noticeable that in the exon model case some exons have
zero counts, which are indicated by white filled rectangles, in one condition, 
whereas in the edges model case we still have counts. This is another
sign for increased robustness in the splice graph edges approach
compared to the classic exon model approach.

\begin{figure}[H]
  \begin{center}
    \includegraphics[width=\textwidth]{Edge-plot.png}
  \end{center}
  \caption{Expression levels of the edges of gene 90522 (YIF1B). The
    purple rectangle in the edges model indicate significant (FDR$<$0.1)
    differentially expressed edges. Grey rectangles indicate edges
    with at least on read count and white rectangles reflect edges with
    zero counts.
  }
  \label{img:EdgePlot}
\end{figure}


\begin{figure}[H]
  \begin{center}
    \includegraphics[width=\textwidth]{Ex-plot.png}
  \end{center}
  \caption{Expression levels of the exons of gene 90522 (YIF1B). The
    purple rectangle in the exons model indicate significant (FDR$<$0.1)
    differentially expressed exons. Grey rectangles indicate exons
    with at least on read count and white rectangles reflect exons with
    zero counts.
  }
  \label{img:ExPlot}
\end{figure}



\section{Combining splice event information with RNA seq data}

This section deals with how to utilize the information
of alternative splicing events provided by the
\Rfunction{spliceGraph} function in term of RNA-Seq data.

from the splicing graph together with the differential edge
expression results of RNA-Seq data. In the previous
section we already identified the differentially expressed edges.
By thinking about the the most simple and most often occurring splice event, 
one exon skipping, it is pretty easy to draw conclusions out of the 
differential edge analysis. If an edge representing the
skipped exon of a skip 1 exon event is higher expressed in tumor samples 
compared to normal ones, it would suggest that exon skipping is prevented 
for some reason in the tumor.

The key for mapping the data of the differential edge expression
analysis to the splice event information are the edge IDs.
First of all we create a simple link the edges to splice events (bubbles). 
Then we look for the edges assigned to 1 exon
skipping events to check if they are under or over represented. If such an edge
would be overrepresented in the normal samples compared to the tumor
samples this would mean that in the tumor the exon skip is promoted.

Get the mapping of the edges to the bubbles and the  associated splice
events.

<<>>=
bubID <- values(sg)[["bubble_ids"]]
eid <- rep(names(sg), elementLengths(bubID))
rownames(spliceEvents) <- spliceEvents$bubbleCode

bubID <- unlist(bubID, use.names=FALSE)

eidToBubID <- 
  data.frame(bubID, eid,
             eventType=spliceEvents[bubID,]$eventType)
@ 

Assign the differential expression analysis results to the annotated
splice events.

<<>>=
eidToBubID <- eidToBubID[!is.na(eidToBubID$eventType) &
                         !is.na(eidToBubID$eventType ), ]

finTT.Edge <- finTT.Edge[finTT.Edge$id %in% eidToBubID$eid, ]

rownames(finTT.Edge) <- as.character(finTT.Edge$id)
eidToBubID <- eidToBubID[eidToBubID$eid %in% 
                         rownames(finTT.Edge),]

Res <- data.frame(eidToBubID, 
                  finTT.Edge[as.character(eidToBubID$eid),])

Res <- Res[order(Res$pval), ]
@ 

Next we have a look onto Table \ref{table:events} displaying the 
the significant edges corresponding to annotated splice events.

<<rr, results=tex, echo=FALSE>>=
T <- head(Res[, c("gnID","padj", "pval", "log2FoldChange",  "eventType")], n=15)
colnames(T) <- c("gnID", "padj", "pval", "log2FC", "event")
T <- xtable(T, caption="The 15 most significant annotated splice events affacted by differential expression.", 
            label="table:events", display=c("s", "s","E", "E","f","s"))
align(T) <- "lrrrrp{5cm}"
print(T, include.rownames=FALSE, table.placement="H")
@ 

We have found only 3 significant edges which are associated with
annotated splice events, but if the code presented in this vignette is
used for the whole genome it could provide some new aspects.

\section{Summary}

The introduced splice graph approach to identify differential
expression of annotated splice variants based on RNA-Seq data
seems to be promising. Especially a higher number of total read counts, 
increased robustness as well as increased statistical power for the testing
seem to be the most remarkable advantages of this new methodology.
Additionally information about the underlying splicing mechanisms are provided
which could bring further biological relevant insights.


\bibliography{spliceGraph}
\bibliographystyle{plain}


\section{Session Information}

\begin{scriptsize}
<<SessionInfo, echo=FALSE>>=
sessionInfo()
@
\end{scriptsize}

\end{document}
